# GitHub Copilot Instructions for Creator World Backend

## Project Overview
Creator World Backend is a production-grade Node.js/Express API for a Stan-store like platform. Built with TypeScript, PostgreSQL, Redis, and following enterprise-level software engineering practices.

## Core Architecture Principles

### 1. Feature-Based Module Architecture
```
Modules (Features)
├── Auth, Users, Products, Orders, etc.
└── Each module: Routes → Controllers → Services → Models

Common
├── Middleware (Auth, Validation, Error handling, Logging)
└── Utils (Helpers, Cache, Logger, Response, Pagination)

Config
└── Database, Redis, Environment
```

**Key Principle**: Group related features into modules, not layers. Each module is self-contained with its own controller, service, and routes.

### 2. Module Structure
```
src/modules/{moduleName}/
├── {moduleName}.controller.ts  - HTTP handlers
├── {moduleName}.service.ts     - Business logic
├── {moduleName}.routes.ts      - Route definitions
└── index.ts                    - Module exports
```

### 3. Shared Resources
```
src/common/
├── middleware/                 - Global/reusable middleware
│   ├── auth.middleware.ts      - Authentication
│   ├── validation.middleware.ts - Request validation
│   ├── errorHandler.middleware.ts - Error handling
│   ├── logger.middleware.ts    - HTTP logging
│   └── role.middleware.ts      - Role-based access
└── utils/                      - Shared utilities
    ├── response.ts             - Response formatting
    ├── helpers.ts              - Utility functions
    ├── logger.ts               - Winston logger
    ├── cache.ts                - Redis caching
    └── pagination.ts           - Pagination helpers
```

### 4. Dependency Injection Pattern
- Services depend on models and utilities
- Controllers depend on services
- Instantiate new instances in controllers for simplicity
- Can be refactored to DI container if needed

### 5. Type Safety
- All functions have explicit return types
- Strict TypeScript mode enabled
- Use interfaces and enums for domain models
- DTOs for API contracts

## Code Structure Guidelines

### File Naming Conventions
```
{feature}.controller.ts      # Controllers
{feature}.service.ts         # Services
{feature}.routes.ts          # Routes
{feature}.dto.ts            # Data Transfer Objects
{feature}.validator.ts      # Request validators
```

### Import Paths (TypeScript Aliases)
```typescript
// ✅ Use path aliases
import { AuthService } from '@modules/auth/auth.service';
import { UserController } from '@modules/users/user.controller';
import { authMiddleware } from '@common/middleware/auth.middleware';
import { sendResponse, AppError } from '@common/utils/response';
import { logger } from '@common/utils/logger';
import { config } from '@config/environment';

// ❌ Avoid relative imports
import { AuthService } from '../../modules/auth/auth.service';
```

### Available Path Aliases
```typescript
@config/*       // src/config/
@common/*       // src/common/
@modules/*      // src/modules/
@models/*       // src/models/
@constants/*    // src/constants/
@dto/*          // src/dto/
@validators/*   // src/validators/
@types/*        // src/types/
```

## Creating New Features

### Step 1: Define Data Transfer Objects (DTO)
```typescript
// src/dto/feature.dto.ts
export class CreateFeatureDTO {
  name!: string;
  description?: string;
}

export class FeatureResponseDTO {
  id!: string;
  name!: string;
  // ... response fields
}
```

### Step 2: Create Request Validators
```typescript
// src/validators/feature.validator.ts
import Joi from 'joi';

export const createFeatureSchema = Joi.object({
  body: Joi.object({
    name: Joi.string().required(),
    description: Joi.string().optional(),
  }),
});
```

### Step 3: Create Service (Business Logic)
```typescript
// src/modules/feature/feature.service.ts
import { CreateFeatureDTO } from '@dto/feature.dto';
import { AppError } from '@common/utils/response';
import { Feature } from '@models/Feature';

export class FeatureService {

  async createFeature(dto: CreateFeatureDTO): Promise<any> {
    // Validate business rules
    if (!dto.name) {
      throw new AppError(400, 'Name is required');
    }

    // Use models (Sequelize)
    const feature = await Feature.create(dto);

    return this.toResponseDTO(feature);
  }

  private toResponseDTO(feature: any): any {
    return {
      id: feature.id,
      name: feature.name,
      // ... map fields
    };
  }
}
```

### Step 4: Create Controller (HTTP Handlers)
```typescript
// src/modules/feature/feature.controller.ts
import { Request, Response, NextFunction } from 'express';
import { FeatureService } from './feature.service';
import { asyncHandler, sendResponse, AppError } from '@common/utils/response';
import { RESPONSE_MESSAGES } from '@constants/messages';

export class FeatureController {
  private service = new FeatureService();

  createFeature = asyncHandler(
    async (req: Request, res: Response, next: NextFunction): Promise<void> => {
      try {
        const result = await this.service.createFeature(req.body);
        sendResponse(res, 201, RESPONSE_MESSAGES.CREATED, result);
      } catch (error) {
        if (error instanceof AppError) {
          throw error;
        }
        throw new AppError(500, RESPONSE_MESSAGES.INTERNAL_ERROR);
      }
    }
  );

  // ... other handlers
}
```

### Step 5: Create Routes
```typescript
// src/modules/feature/feature.routes.ts
import { Router } from 'express';
import { FeatureController } from './feature.controller';
import { validateRequest } from '@common/middleware/validation.middleware';
import { createFeatureSchema } from '@validators/feature.validator';
import { authMiddleware } from '@common/middleware/auth.middleware';

const router = Router();
const controller = new FeatureController();

/**
 * @route POST /features
 * @desc Create a new feature
 * @access Private
 */
router.post(
  '/', 
  authMiddleware, 
  validateRequest(createFeatureSchema), 
  controller.createFeature
);

/**
 * @route GET /features/:id
 * @desc Get feature by ID
 * @access Public
 */
router.get('/:id', controller.getFeature);

export default router;
```

### Step 6: Create Module Index (Exports)
```typescript
// src/modules/feature/index.ts
export { FeatureService } from './feature.service';
export { FeatureController } from './feature.controller';
export { default as featureRoutes } from './feature.routes';
```

### Step 7: Register Routes in App
```typescript
// src/app.ts
import { featureRoutes } from '@modules/feature';

// Add after other route registrations
app.use(`/api/${config.app.apiVersion}/features`, featureRoutes);
```

## Error Handling

### Using AppError
```typescript
// Throw custom errors with status codes
import { AppError } from '@common/utils/response';

throw new AppError(404, 'Resource not found');
throw new AppError(400, 'Validation failed', true, { field: 'email' });

// Errors are caught by errorHandler middleware
// Response is automatically formatted
```

### Response Format
```json
{
  "success": false,
  "statusCode": 400,
  "message": "Error message",
  "details": { /* optional */ }
}
```

## Caching Strategy

### Use Redis Cache for Performance
```typescript
import { cacheGetOrSet, cacheSet, cacheDel } from '@common/utils/cache';

// Automatically cache with fallback
const user = await cacheGetOrSet(
  `user:${userId}`,
  () => User.findByPk(userId),
  3600 // TTL in seconds
);

// Invalidate cache after updates
await cacheDel(`user:${userId}`);
```

## Validation

### Request Validation with Joi
```typescript
import { validateRequest } from '@common/middleware/validation.middleware';

// Define schema
const schema = Joi.object({
  body: Joi.object({
    email: Joi.string().email().required(),
    age: Joi.number().min(18).max(120).optional(),
  }),
  query: Joi.object({
    page: Joi.number().min(1).optional(),
  }),
});

// Use in routes
router.post('/', validateRequest(schema), controller.handler);
```

## Database Queries

### Using Sequelize Models
```typescript
import { User } from '@models/User';

// Fetch with associations
const user = await User.findByPk(userId, {
  include: ['profile', 'products'],
});

// Pagination
const { skip, take } = getPaginationParams(page, limit);
const users = await User.findAll({ 
  offset: skip, 
  limit: take 
});

// Filtering
const products = await Product.findAll({
  where: { creatorId, status: 'published' },
});

// Count
const total = await User.count();

// Update
await user.update(updateData);

// Delete
await user.destroy();
```

## Authentication

### Protected Routes
```typescript
// Use authMiddleware
import { authMiddleware } from '@common/middleware/auth.middleware';

router.get('/profile', authMiddleware, controller.getProfile);

// Extract user from request
const userId = (req as AuthRequest).user.id;
```

### JWT Tokens
```typescript
import { generateToken, verifyToken } from '@common/utils/helpers';

// Generate
const token = generateToken({
  id: user.id,
  email: user.email,
  username: user.username,
});

// Verify (automatic in middleware)
const decoded = verifyToken(token);
```

## Logging

### Use Winston Logger
```typescript
import { logger } from '@common/utils/logger';

logger.info('User registered', { userId, email });
logger.error('Database error', error);
logger.warn('Rate limit approaching');
logger.debug('Processing user request');
```

## Testing

### Unit Test Structure
```typescript
describe('FeatureService', () => {
  let service: FeatureService;

  beforeEach(() => {
    service = new FeatureService();
  });

  it('should create a feature', async () => {
    const result = await service.createFeature({ name: 'Test' });
    expect(result).toBeDefined();
  });
});
```

## Environment Configuration

### Add New Config Variables
1. Add to `.env.example`
2. Define in `src/config/environment.ts`
3. Use via `config.section.variable`

```typescript
// In environment.ts
export const config = {
  myFeature: {
    apiKey: process.env.MY_FEATURE_API_KEY || '',
    enabled: process.env.MY_FEATURE_ENABLED === 'true',
  },
};

// In services
import { config } from '@config/environment';
const apiKey = config.myFeature.apiKey;
```

## Performance Best Practices

1. **Pagination**: Always paginate large result sets
2. **Caching**: Cache frequently accessed data in Redis
3. **Database**: Use indexes, eager-load relations, avoid N+1 queries
4. **Queries**: Select only needed fields or use include/exclude
5. **Connections**: Use connection pooling (configured in .env)

## Security Best Practices

1. **Passwords**: Always hash with bcrypt, never log passwords
2. **Tokens**: Don't expose tokens in logs, use secure expiration
3. **Validation**: Validate all inputs with Joi schemas
4. **CORS**: Whitelist origins in config
5. **Helmet**: Already configured for security headers
6. **Environment**: Never commit .env file
7. **Roles**: Use roleMiddleware for role-based access control

## Code Quality Standards

### Linting
```bash
npm run lint      # Check
npm run lint:fix  # Fix automatically
```

### Formatting
```bash
npm run format    # Format with Prettier
```

### Type Checking
```bash
npm run type-check  # Find type errors
```

## Common Patterns

### Async Error Handling in Controllers
```typescript
import { asyncHandler, sendResponse, AppError } from '@common/utils/response';

controller = asyncHandler(async (req, res, next) => {
  try {
    const result = await service.method();
    sendResponse(res, 200, 'Success', result);
  } catch (error) {
    if (error instanceof AppError) {
      throw error; // asyncHandler catches it
    }
    throw new AppError(500, 'Internal Error');
  }
});
```

### Pagination Response
```typescript
import { sendResponse } from '@common/utils/response';

const { data, meta } = await service.getPaginated(page, limit);
sendResponse(res, 200, 'Success', data, meta);
```

### Filtered Queries
```typescript
const filters = {
  category: req.query.category,
  search: req.query.search,
};
const results = await service.findWithFilters(filters, page, limit);
```

## Extending the API

### Adding a New Module

1. Create directory: `src/modules/{moduleName}/`
2. Create DTOs in `src/dto/` if needed
3. Create validators in `src/validators/` if needed
4. Create service: `{moduleName}.service.ts`
5. Create controller: `{moduleName}.controller.ts`
6. Create routes: `{moduleName}.routes.ts`
7. Create index: `index.ts` with exports
8. Register in `src/app.ts`
9. Add tests

### Adding Middleware

1. Create in `src/common/middleware/` with `.middleware.ts` suffix
2. Import in routes or globally in `app.ts`
3. Document its purpose

### Adding Utilities

1. Create in `src/common/utils/`
2. Export functions
3. Use via `@common/utils/` alias

## Debugging

### Development Mode
```bash
npm run dev  # Includes source maps and verbose logging
```

### Check Logs
```
logs/error.log  # Error log file
logs/all.log    # All events
```

## API Response Standards

### Success Response
```json
{
  "success": true,
  "statusCode": 200,
  "message": "Operation successful",
  "data": { /* ... */ },
  "meta": { "page": 1, "limit": 20 }
}
```

### Error Response
```json
{
  "success": false,
  "statusCode": 400,
  "message": "Validation failed",
  "details": { "field": "Error message" }
}
```

## Production Deployment

### Before Deploying
- [ ] Set NODE_ENV=production
- [ ] Use strong JWT_SECRET
- [ ] Configure PostgreSQL with proper user permissions
- [ ] Setup Redis for production
- [ ] Configure CORS for frontend domain
- [ ] Enable rate limiting
- [ ] Setup monitoring and alerting
- [ ] Configure SSL/TLS
- [ ] Setup CI/CD pipeline
- [ ] Review security settings

### Database Migrations
```bash
npm run db:migrate  # Apply pending migrations
```

## Useful Commands Reference

```bash
npm run dev              # Start development server
npm run build            # Build to JavaScript
npm start                # Run production build
npm test                 # Run all tests
npm run lint             # Check code style
npm run lint:fix         # Auto-fix code style
npm run format           # Format code
npm run type-check       # Check types
npm run db:migrate       # Run migrations
npm run db:seed          # Seed database
```

---

## Quick Tips

1. Always use DTOs for API responses
2. Validate inputs with Joi validators, not in services
3. Use models (Sequelize) for all database access
4. Throw AppError for business logic errors
5. Cache expensive operations with Redis
6. Log important events and errors
7. Test before pushing code
8. Follow the established module patterns
9. Use path aliases (@modules, @common, @config, etc.)
10. Keep functions small and focused
11. Group related features in modules
12. Place shared code in @common directory

This ensures maintainability, scalability, and consistency across the codebase.

